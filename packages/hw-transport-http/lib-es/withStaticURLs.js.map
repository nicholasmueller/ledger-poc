{"version":3,"sources":["../src/withStaticURLs.js"],"names":["HttpTransport","WebSocketTransport","Transport","getTransport","url","startsWith","inferURLs","urls","r","StaticTransport","isSupported","list","then","Promise","all","map","check","catch","arrs","reduce","acc","a","concat","listen","observer","unsubscribed","seen","checkLoop","next","type","descriptor","e","success","setTimeout","unsubscribe","open"],"mappings":"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","sourcesContent":["// @flow\nimport HttpTransport from \"./HttpTransport\";\nimport WebSocketTransport from \"./WebSocketTransport\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\n\nconst getTransport = (url) =>\n  !url.startsWith(\"ws\") ? HttpTransport : WebSocketTransport;\n\ntype InS = string | string[];\ntype InP = Promise<InS> | InS;\ntype In = InP | (() => InP);\n\nconst inferURLs = async (urls: In): Promise<string[]> => {\n  const r = await (typeof urls === \"function\" ? urls() : urls);\n  return typeof r === \"string\" ? [r] : r;\n};\n\nexport default (urls: In): Class<Transport<string>> => {\n  class StaticTransport extends Transport<string> {\n    static isSupported = HttpTransport.isSupported;\n\n    static list = (): Promise<*[]> =>\n      inferURLs(urls)\n        .then((urls) =>\n          Promise.all(\n            urls.map((url) =>\n              getTransport(url)\n                .check(url)\n                .then(() => [url])\n                .catch(() => [])\n            )\n          )\n        )\n        .then((arrs) => arrs.reduce((acc, a) => acc.concat(a), []));\n\n    static listen = (observer: Observer<DescriptorEvent<*>>): Subscription => {\n      let unsubscribed = false;\n      const seen = {};\n      function checkLoop() {\n        if (unsubscribed) return;\n        inferURLs(urls)\n          .then((urls) =>\n            Promise.all(\n              urls.map(async (url) => {\n                if (unsubscribed) return;\n                try {\n                  await getTransport(url).check(url);\n                  if (unsubscribed) return;\n                  if (!seen[url]) {\n                    seen[url] = 1;\n                    observer.next({ type: \"add\", descriptor: url });\n                  }\n                } catch (e) {\n                  // nothing\n                  if (seen[url]) {\n                    delete seen[url];\n                    observer.next({ type: \"remove\", descriptor: url });\n                  }\n                }\n              })\n            )\n          )\n          .then(() => new Promise((success) => setTimeout(success, 5000)))\n          .then(checkLoop);\n      }\n      checkLoop();\n      return {\n        unsubscribe: () => {\n          unsubscribed = true;\n        },\n      };\n    };\n\n    static open = (url) => getTransport(url).open(url);\n  }\n\n  return StaticTransport;\n};\n"],"file":"withStaticURLs.js"}