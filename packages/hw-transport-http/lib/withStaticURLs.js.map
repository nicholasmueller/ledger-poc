{"version":3,"sources":["../src/withStaticURLs.js"],"names":["getTransport","url","startsWith","HttpTransport","WebSocketTransport","inferURLs","urls","r","StaticTransport","Transport","isSupported","list","then","Promise","all","map","check","catch","arrs","reduce","acc","a","concat","listen","observer","unsubscribed","seen","checkLoop","next","type","descriptor","e","success","setTimeout","unsubscribe","open"],"mappings":"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","sourcesContent":["// @flow\nimport HttpTransport from \"./HttpTransport\";\nimport WebSocketTransport from \"./WebSocketTransport\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\n\nconst getTransport = (url) =>\n  !url.startsWith(\"ws\") ? HttpTransport : WebSocketTransport;\n\ntype InS = string | string[];\ntype InP = Promise<InS> | InS;\ntype In = InP | (() => InP);\n\nconst inferURLs = async (urls: In): Promise<string[]> => {\n  const r = await (typeof urls === \"function\" ? urls() : urls);\n  return typeof r === \"string\" ? [r] : r;\n};\n\nexport default (urls: In): Class<Transport<string>> => {\n  class StaticTransport extends Transport<string> {\n    static isSupported = HttpTransport.isSupported;\n\n    static list = (): Promise<*[]> =>\n      inferURLs(urls)\n        .then((urls) =>\n          Promise.all(\n            urls.map((url) =>\n              getTransport(url)\n                .check(url)\n                .then(() => [url])\n                .catch(() => [])\n            )\n          )\n        )\n        .then((arrs) => arrs.reduce((acc, a) => acc.concat(a), []));\n\n    static listen = (observer: Observer<DescriptorEvent<*>>): Subscription => {\n      let unsubscribed = false;\n      const seen = {};\n      function checkLoop() {\n        if (unsubscribed) return;\n        inferURLs(urls)\n          .then((urls) =>\n            Promise.all(\n              urls.map(async (url) => {\n                if (unsubscribed) return;\n                try {\n                  await getTransport(url).check(url);\n                  if (unsubscribed) return;\n                  if (!seen[url]) {\n                    seen[url] = 1;\n                    observer.next({ type: \"add\", descriptor: url });\n                  }\n                } catch (e) {\n                  // nothing\n                  if (seen[url]) {\n                    delete seen[url];\n                    observer.next({ type: \"remove\", descriptor: url });\n                  }\n                }\n              })\n            )\n          )\n          .then(() => new Promise((success) => setTimeout(success, 5000)))\n          .then(checkLoop);\n      }\n      checkLoop();\n      return {\n        unsubscribe: () => {\n          unsubscribed = true;\n        },\n      };\n    };\n\n    static open = (url) => getTransport(url).open(url);\n  }\n\n  return StaticTransport;\n};\n"],"file":"withStaticURLs.js"}