{"version":3,"sources":["../src/TransportWebAuthn.js"],"names":["attemptExchange","apdu","timeout","scrambleKey","TransportError","navigator","credentials","get","publicKey","challenge","Uint8Array","allowCredentials","type","id","then","r","Buffer","from","response","signature","TransportWebAuthn","Transport","open","exchange","toString","res","exchangeTimeout","setScrambleKey","close","Promise","resolve","isSupported","list","listen","observer","setTimeout","error","unsubscribe","next","descriptor","complete"],"mappings":";;;;;;;AAEA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,eAAe,GAAG,CACtBC,IADsB,EAEtBC,OAFsB,EAGtBC,WAHsB,KAIF;AACpB,MAAI,CAACA,WAAL,EAAkB;AAChB,UAAM,IAAIC,sBAAJ,CACJ,sFADI,EAEJ,eAFI,CAAN;AAID;;AAED,MAAI,CAACC,SAAS,CAACC,WAAf,EAA4B;AAC1B,UAAM,IAAIF,sBAAJ,CAAmB,wBAAnB,EAA6C,cAA7C,CAAN;AACD;;AAED,SACEC,SAAS,CAACC,WAAV,CACE;AADF,GAEGC,GAFH,CAEO;AACHC,IAAAA,SAAS,EAAE;AACTN,MAAAA,OADS;AAETO,MAAAA,SAAS,EAAE,IAAIC,UAAJ,CAAe,EAAf,CAFF;AAGTC,MAAAA,gBAAgB,EAAE,CAChB;AACEC,QAAAA,IAAI,EAAE,YADR;AAEEC,QAAAA,EAAE,EAAE,IAAIH,UAAJ,CAAe,0BAAST,IAAT,EAAeE,WAAf,CAAf;AAFN,OADgB;AAHT;AADR,GAFP,EAcE;AAdF,GAeGW,IAfH,CAeSC,CAAD,IAAOC,MAAM,CAACC,IAAP,CAAYF,CAAC,CAACG,QAAF,CAAWC,SAAvB,CAff,CADF;AAkBD,CAlCD;AAoCA;;;;;;;;;AAOe,MAAMC,iBAAN,SAAgCC,oBAAhC,CAAgD;AAAA;AAAA;AAAA,SAuB7DlB,WAvB6D;AAAA;;AAyB7D,eAAamB,IAAb,GAAgD;AAC9C,WAAO,IAAIF,iBAAJ,EAAP;AACD;AAED;;;;;;;AAKA,QAAMG,QAAN,CAAetB,IAAf,EAA8C;AAC5C,mBAAI,MAAJ,EAAY,QAAQA,IAAI,CAACuB,QAAL,CAAc,KAAd,CAApB;AACA,UAAMC,GAAG,GAAG,MAAMzB,eAAe,CAC/BC,IAD+B,EAE/B,KAAKyB,eAF0B,EAG/B,KAAKvB,WAH0B,CAAjC;AAKA,mBAAI,MAAJ,EAAY,QAAQsB,GAAG,CAACD,QAAJ,CAAa,KAAb,CAApB;AACA,WAAOC,GAAP;AACD;AAED;;;;;;;;;;AAQAE,EAAAA,cAAc,CAACxB,WAAD,EAAsB;AAClC,SAAKA,WAAL,GAAmBa,MAAM,CAACC,IAAP,CAAYd,WAAZ,EAAyB,OAAzB,CAAnB;AACD;;AAEDyB,EAAAA,KAAK,GAAkB;AACrB,WAAOC,OAAO,CAACC,OAAR,EAAP;AACD;;AA3D4D;;;;AAA1CV,iB,CACZW,W,GAAc,MAAMF,OAAO,CAACC,OAAR,CAAgB,CAAC,CAACzB,SAAS,CAACC,WAA5B,C;;AADRc,iB,CAKZY,I,GAAO,MAAU3B,SAAS,CAACC,WAAV,GAAwB,CAAC,IAAD,CAAxB,GAAiC,E;;AALtCc,iB,CASZa,M,GAAUC,QAAD,IAAiB;AAC/BC,EAAAA,UAAU,CAAC,MAAM;AACf,QAAI,CAAC9B,SAAS,CAACC,WAAf,EAA4B;AAC1B4B,MAAAA,QAAQ,CAACE,KAAT,CACE,IAAIhC,sBAAJ,CAAmB,wBAAnB,EAA6C,cAA7C,CADF;AAGA,aAAO;AAAEiC,QAAAA,WAAW,EAAE,MAAM,CAAE;AAAvB,OAAP;AACD;;AACDH,IAAAA,QAAQ,CAACI,IAAT,CAAc;AAAE1B,MAAAA,IAAI,EAAE,KAAR;AAAe2B,MAAAA,UAAU,EAAE;AAA3B,KAAd;AACAL,IAAAA,QAAQ,CAACM,QAAT;AACD,GATS,EASP,CATO,CAAV;AAUA,SAAO;AAAEH,IAAAA,WAAW,EAAE,MAAM,CAAE;AAAvB,GAAP;AACD,C","sourcesContent":["//@flow\n\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport { wrapApdu } from \"@ledgerhq/devices/lib/scrambling\";\nimport { log } from \"@ledgerhq/logs\";\n\nconst attemptExchange = (\n  apdu: Buffer,\n  timeout: number,\n  scrambleKey: ?Buffer\n): Promise<Buffer> => {\n  if (!scrambleKey) {\n    throw new TransportError(\n      \"transport.setScrambleKey must be used to set a scramble key. Refer to documentation.\",\n      \"NoScrambleKey\"\n    );\n  }\n\n  if (!navigator.credentials) {\n    throw new TransportError(\"WebAuthn not supported\", \"NotSupported\");\n  }\n\n  return (\n    navigator.credentials\n      // $FlowFixMe\n      .get({\n        publicKey: {\n          timeout,\n          challenge: new Uint8Array(32),\n          allowCredentials: [\n            {\n              type: \"public-key\",\n              id: new Uint8Array(wrapApdu(apdu, scrambleKey)),\n            },\n          ],\n        },\n      })\n      // $FlowFixMe\n      .then((r) => Buffer.from(r.response.signature))\n  );\n};\n\n/**\n * WebAuthn Transport implementation\n * @example\n * import TransportWebAuthn from \"@ledgerhq/hw-transport-webauthn\";\n * ...\n * TransportWebAuthn.create().then(transport => ...)\n */\nexport default class TransportWebAuthn extends Transport<null> {\n  static isSupported = () => Promise.resolve(!!navigator.credentials);\n\n  /*\n   */\n  static list = (): * => (navigator.credentials ? [null] : []);\n\n  /*\n   */\n  static listen = (observer: *) => {\n    setTimeout(() => {\n      if (!navigator.credentials) {\n        observer.error(\n          new TransportError(\"WebAuthn not supported\", \"NotSupported\")\n        );\n        return { unsubscribe: () => {} };\n      }\n      observer.next({ type: \"add\", descriptor: null });\n      observer.complete();\n    }, 0);\n    return { unsubscribe: () => {} };\n  };\n\n  scrambleKey: ?Buffer;\n\n  static async open(): Promise<TransportWebAuthn> {\n    return new TransportWebAuthn();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n    const res = await attemptExchange(\n      apdu,\n      this.exchangeTimeout,\n      this.scrambleKey\n    );\n    log(\"apdu\", \"<= \" + res.toString(\"hex\"));\n    return res;\n  }\n\n  /**\n   * A scramble key is a string that xor the data exchanged.\n   * It depends on the device app you need to exchange with.\n   * For instance it can be \"BTC\" for the bitcoin app, \"B0L0S\" for the dashboard.\n   *\n   * @example\n   * transport.setScrambleKey(\"B0L0S\")\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n"],"file":"TransportWebAuthn.js"}