{"version":3,"sources":["../src/RecordStore.js"],"names":["RecordStoreInvalidSynthax","message","name","stack","Error","prototype","RecordStoreQueueEmpty","RecordStoreWrongAPDU","expected","got","line","expectedAPDU","gotAPDU","RecordStoreRemainingAPDU","defaultOpts","autoSkipUnknownApdu","warning","log","console","warn","RecordStore","constructor","queue","opts","passed","isEmpty","length","recordExchange","apdu","out","push","toString","replayExchange","apduHex","i","head","slice","Buffer","from","ensureQueueEmpty","map","send","receive","join","fromString","str","value","split","replace","filter","o","forEach","m","match"],"mappings":"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","sourcesContent":["//@flow\n\n/**\n * thrown by the RecordStore.fromString parser.\n */\nexport function RecordStoreInvalidSynthax(message: string) {\n  this.name = \"RecordStoreInvalidSynthax\";\n  this.message = message;\n  this.stack = new Error().stack;\n}\n//$FlowFixMe\nRecordStoreInvalidSynthax.prototype = new Error();\n\n/**\n * thrown by the replayer if the queue is empty\n */\nexport function RecordStoreQueueEmpty() {\n  this.name = \"RecordStoreQueueEmpty\";\n  this.message = \"EOF: no more APDU to replay\";\n  this.stack = new Error().stack;\n}\n//$FlowFixMe\nRecordStoreQueueEmpty.prototype = new Error();\n\n/**\n * thrown by replayer if it meets an unexpected apdu\n */\nexport function RecordStoreWrongAPDU(\n  expected: string,\n  got: string,\n  line: number\n) {\n  this.name = \"RecordStoreWrongAPDU\";\n  this.message = `wrong apdu to replay line ${line}. Expected ${expected}, Got ${got}`;\n  this.expectedAPDU = expected;\n  this.gotAPDU = got;\n  this.stack = new Error().stack;\n}\n//$FlowFixMe\nRecordStoreWrongAPDU.prototype = new Error();\n\n/**\n * thrown by ensureQueueEmpty\n */\nexport function RecordStoreRemainingAPDU(expected: string) {\n  this.name = \"RecordStoreRemainingAPDU\";\n  this.message = `replay expected more APDUs to come:\\n${expected}`;\n  this.stack = new Error().stack;\n}\n//$FlowFixMe\nRecordStoreRemainingAPDU.prototype = new Error();\n\nexport type Queue = [string, string][];\n\n/**\n * - autoSkipUnknownApdu:\n * smart mechanism that would skip an apdu un-recognize to the next one that does\n * this is meant to be used when you have refactored/dropped some APDUs\n * it will produces warnings for you to fix the APDUs queue\n * - warning:\n * allows to override the warning function (defaults to console.warn)\n */\nexport type RecordStoreOptions = {\n  autoSkipUnknownApdu: boolean,\n  warning: (string) => void,\n};\n\nconst defaultOpts: RecordStoreOptions = {\n  autoSkipUnknownApdu: false,\n  warning: (log) => console.warn(log),\n};\n\n/**\n * a RecordStore is a stateful object that represents a queue of APDUs.\n * It is both used by replayer and recorder transports and is the basic for writing Ledger tests with a mock device.\n */\nexport class RecordStore {\n  passed = 0;\n  queue: Queue;\n  opts: RecordStoreOptions;\n\n  constructor(queue?: ?Queue, opts?: $Shape<RecordStoreOptions>) {\n    this.queue = queue || [];\n    this.opts = { ...defaultOpts, ...opts };\n  }\n\n  /**\n   * check if there is no more APDUs to replay\n   */\n  isEmpty = () => this.queue.length === 0;\n\n  /**\n   * Record an APDU (used by createTransportRecorder)\n   * @param {Buffer} apdu input\n   * @param {Buffer} out response\n   */\n  recordExchange(apdu: Buffer, out: Buffer) {\n    this.queue.push([apdu.toString(\"hex\"), out.toString(\"hex\")]);\n  }\n\n  /**\n   * Replay an APDU (used by createTransportReplayer)\n   * @param apdu\n   */\n  replayExchange(apdu: Buffer): Buffer {\n    const { queue, opts } = this;\n    const apduHex = apdu.toString(\"hex\");\n    for (let i = 0; i < queue.length; i++) {\n      const head = queue[i];\n      const line = 2 * (this.passed + i);\n      if (apduHex === head[0]) {\n        ++this.passed;\n        this.queue = queue.slice(i + 1);\n        return Buffer.from(head[1], \"hex\");\n      } else {\n        if (opts.autoSkipUnknownApdu) {\n          opts.warning(\n            \"skipped unmatched apdu (line \" +\n              line +\n              \" â€“ expected \" +\n              head[0] +\n              \")\"\n          );\n          ++this.passed;\n        } else {\n          throw new RecordStoreWrongAPDU(head[0], apduHex, line);\n        }\n      }\n    }\n    this.queue = [];\n    throw new RecordStoreQueueEmpty();\n  }\n\n  /**\n   * Check all APDUs was replayed. Throw if it's not the case.\n   */\n  ensureQueueEmpty() {\n    if (!this.isEmpty()) {\n      throw new RecordStoreRemainingAPDU(this.toString());\n    }\n  }\n\n  /**\n   * Print out the series of apdus\n   */\n  toString(): string {\n    return (\n      this.queue\n        .map(([send, receive]) => `=> ${send}\\n<= ${receive}`)\n        .join(\"\\n\") + \"\\n\"\n    );\n  }\n\n  /**\n   * Create a RecordStore by parsing a string (a series of => HEX\\n<= HEX)\n   * @param {string} series of APDUs\n   * @param {$Shape<RecordStoreOptions>} opts\n   */\n  static fromString(\n    str: string,\n    opts?: $Shape<RecordStoreOptions>\n  ): RecordStore {\n    const queue: Queue = [];\n    let value = [];\n    str\n      .split(\"\\n\")\n      .map((line) => line.replace(/ /g, \"\"))\n      .filter((o) => o)\n      .forEach((line) => {\n        if (value.length === 0) {\n          const m = line.match(/^=>([0-9a-fA-F]+)$/);\n          if (!m) {\n            throw new RecordStoreInvalidSynthax(\"expected an apdu input\");\n          }\n          value.push(m[1]);\n        } else {\n          const m = line.match(/^<=([0-9a-fA-F]+)$/);\n          if (!m) {\n            throw new RecordStoreInvalidSynthax(\"expected an apdu output\");\n          }\n          value.push(m[1]);\n          queue.push([value[0], value[1]]);\n          value = [];\n        }\n      });\n    if (value.length !== 0) {\n      throw new RecordStoreInvalidSynthax(\"unexpected end of file\");\n    }\n    return new RecordStore(queue, opts);\n  }\n}\n"],"file":"RecordStore.js"}