{"version":3,"sources":["../src/Trx.js"],"names":["splitPath","foreach","decodeVarint","remapTransactionRelatedErrors","e","statusCode","PATH_SIZE","PATHS_LENGTH_SIZE","CLA","ADDRESS","SIGN","SIGN_HASH","SIGN_MESSAGE","ECDH_SECRET","VERSION","CHUNK_SIZE","Trx","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","path","boolDisplay","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","slice","toString","address","getNextLength","tx","field","data","pos","value","signTransaction","rawTxHex","tokenSignatures","rawTx","from","toSend","newpos","Error","push","concat","startBytes","tokenPos","undefined","i","apduResponse","signTransactionHash","rawTxHashHex","getAppConfiguration","signByHash","truncateAddress","allowContract","allowData","version","versionN","signPersonalMessage","messageHex","message","offset","size","sizePack","substr","packed","maxChunkSize","chunkSize","copy","getECDHPairKey"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA;AACA,SAASA,SAAT,EAAoBC,OAApB,EAA6BC,YAA7B,QAAiD,SAAjD,C,CACA;;AAGA,MAAMC,6BAA6B,GAAIC,CAAD,IAAO;AAC3C,MAAIA,CAAC,IAAIA,CAAC,CAACC,UAAF,KAAiB,MAA1B,EAAkC,CAChC;AACD;;AACD,SAAOD,CAAP;AACD,CALD;;AAOA,MAAME,SAAS,GAAG,CAAlB;AACA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,GAAG,GAAG,IAAZ;AACA,MAAMC,OAAO,GAAG,IAAhB;AACA,MAAMC,IAAI,GAAG,IAAb;AACA,MAAMC,SAAS,GAAG,IAAlB;AACA,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,WAAW,GAAG,IAApB;AACA,MAAMC,OAAO,GAAG,IAAhB;AACA,MAAMC,UAAU,GAAG,GAAnB;AAEA;;;;;;;;AAOA,eAAe,MAAMC,GAAN,CAAU;AAGvBC,EAAAA,WAAW,CAACC,SAAD,EAA0BC,WAAmB,GAAG,KAAhD,EAAuD;AAAA,SAFlED,SAEkE;AAChE,SAAKA,SAAL,GAAiBA,SAAjB;AACAA,IAAAA,SAAS,CAACE,qBAAV,CACE,IADF,EAEE,CACE,YADF,EAEE,gBAFF,EAGE,iBAHF,EAIE,qBAJF,EAKE,qBALF,EAME,qBANF,CAFF,EAUED,WAVF;AAYD;AAED;;;;;;;;;;AAQAE,EAAAA,UAAU,CACRC,IADQ,EAERC,WAFQ,EAMP;AACD,QAAIC,KAAK,GAAGxB,SAAS,CAACsB,IAAD,CAArB;AACA,QAAIG,MAAM,GAAGC,MAAM,CAACC,KAAP,CAAapB,iBAAiB,GAAGiB,KAAK,CAACI,MAAN,GAAetB,SAAhD,CAAb;AACAmB,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACI,MAAlB;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCN,MAAAA,MAAM,CAACO,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,KAFD;AAGA,WAAO,KAAKb,SAAL,CACJe,IADI,CACCzB,GADD,EACMC,OADN,EACec,WAAW,GAAG,IAAH,GAAU,IADpC,EAC0C,IAD1C,EACgDE,MADhD,EAEJS,IAFI,CAEEC,QAAD,IAAc;AAClB,UAAIC,MAAM,GAAG,EAAb;AACA,UAAIC,eAAe,GAAGF,QAAQ,CAAC,CAAD,CAA9B;AACA,UAAIG,aAAa,GAAGH,QAAQ,CAAC,IAAIE,eAAL,CAA5B;AACAD,MAAAA,MAAM,CAACG,SAAP,GAAmBJ,QAAQ,CACxBK,KADgB,CACV,CADU,EACP,IAAIH,eADG,EAEhBI,QAFgB,CAEP,KAFO,CAAnB;AAGAL,MAAAA,MAAM,CAACM,OAAP,GAAiBP,QAAQ,CACtBK,KADc,CAEb,IAAIH,eAAJ,GAAsB,CAFT,EAGb,IAAIA,eAAJ,GAAsB,CAAtB,GAA0BC,aAHb,EAKdG,QALc,CAKL,OALK,CAAjB;AAMA,aAAOL,MAAP;AACD,KAhBI,CAAP;AAiBD;;AAEDO,EAAAA,aAAa,CAACC,EAAD,EAAa;AACxB,UAAMC,KAAK,GAAG3C,YAAY,CAAC0C,EAAD,EAAK,CAAL,CAA1B;AACA,UAAME,IAAI,GAAG5C,YAAY,CAAC0C,EAAD,EAAKC,KAAK,CAACE,GAAX,CAAzB;AACA,QAAI,CAACF,KAAK,CAACG,KAAN,GAAc,IAAf,MAAyB,CAA7B,EAAgC,OAAOF,IAAI,CAACC,GAAZ;AAChC,WAAOD,IAAI,CAACE,KAAL,GAAaF,IAAI,CAACC,GAAzB;AACD;AAED;;;;;;;;;;;;;;AAYAE,EAAAA,eAAe,CACb3B,IADa,EAEb4B,QAFa,EAGbC,eAHa,EAII;AACjB,UAAM3B,KAAK,GAAGxB,SAAS,CAACsB,IAAD,CAAvB;AACA,QAAI8B,KAAK,GAAG1B,MAAM,CAAC2B,IAAP,CAAYH,QAAZ,EAAsB,KAAtB,CAAZ;AACA,UAAMI,MAAM,GAAG,EAAf;AAEA,QAAIR,IAAI,GAAGpB,MAAM,CAACC,KAAP,CAAapB,iBAAiB,GAAGiB,KAAK,CAACI,MAAN,GAAetB,SAAhD,CAAX,CALiB,CAMjB;;AACAwC,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUtB,KAAK,CAACI,MAAhB;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCe,MAAAA,IAAI,CAACd,aAAL,CAAmBF,OAAnB,EAA4B,IAAI,IAAIC,KAApC;AACD,KAFD;;AAIA,WAAOqB,KAAK,CAACxB,MAAN,GAAe,CAAtB,EAAyB;AACvB;AACA,YAAM2B,MAAM,GAAG,KAAKZ,aAAL,CAAmBS,KAAnB,CAAf;AACA,UAAIG,MAAM,GAAGxC,UAAb,EAAyB,MAAM,IAAIyC,KAAJ,CAAU,2BAAV,CAAN;;AACzB,UAAIV,IAAI,CAAClB,MAAL,GAAc2B,MAAd,GAAuBxC,UAA3B,EAAuC;AACrCuC,QAAAA,MAAM,CAACG,IAAP,CAAYX,IAAZ;AACAA,QAAAA,IAAI,GAAGpB,MAAM,CAACC,KAAP,CAAa,CAAb,CAAP;AACA;AACD,OARsB,CASvB;;;AACAmB,MAAAA,IAAI,GAAGpB,MAAM,CAACgC,MAAP,CAAc,CAACZ,IAAD,EAAOM,KAAK,CAACZ,KAAN,CAAY,CAAZ,EAAee,MAAf,CAAP,CAAd,CAAP;AACAH,MAAAA,KAAK,GAAGA,KAAK,CAACZ,KAAN,CAAYe,MAAZ,EAAoBH,KAAK,CAACxB,MAA1B,CAAR;AACD;;AACD0B,IAAAA,MAAM,CAACG,IAAP,CAAYX,IAAZ;AAEA,UAAMa,UAAU,GAAG,EAAnB;AACA,QAAIxB,QAAJ;AAEA,UAAMyB,QAAQ,GAAGN,MAAM,CAAC1B,MAAxB;;AACA,QAAIuB,eAAe,KAAKU,SAAxB,EAAmC;AACjC,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,eAAe,CAACvB,MAApC,EAA4CkC,CAAC,IAAI,CAAjD,EAAoD;AAClD,cAAMrC,MAAM,GAAGC,MAAM,CAAC2B,IAAP,CAAYF,eAAe,CAACW,CAAD,CAA3B,EAAgC,KAAhC,CAAf;AACAR,QAAAA,MAAM,CAACG,IAAP,CAAYhC,MAAZ;AACD;AACF,KApCgB,CAsCjB;;;AACA,QAAI6B,MAAM,CAAC1B,MAAP,KAAkB,CAAtB,EAAyB;AACvB+B,MAAAA,UAAU,CAACF,IAAX,CAAgB,IAAhB;AACD,KAFD,MAEO;AACLE,MAAAA,UAAU,CAACF,IAAX,CAAgB,IAAhB;;AACA,WAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAAC1B,MAAP,GAAgB,CAApC,EAAuCkC,CAAC,IAAI,CAA5C,EAA+C;AAC7C,YAAIA,CAAC,IAAIF,QAAT,EAAmB;AACjBD,UAAAA,UAAU,CAACF,IAAX,CAAgB,OAAO,IAAP,GAAeK,CAAC,GAAGF,QAAnC,EADiB,CAC8B;AAChD,SAFD,MAEO;AACLD,UAAAA,UAAU,CAACF,IAAX,CAAgB,IAAhB;AACD;AACF;;AACD,UAAIN,eAAe,KAAKU,SAApB,IAAiCV,eAAe,CAACvB,MAArD,EAA6D;AAC3D+B,QAAAA,UAAU,CAACF,IAAX,CAAgB,OAAO,IAAP,GAAeN,eAAe,CAACvB,MAAhB,GAAyB,CAAxD,EAD2D,CACE;AAC9D,OAFD,MAEO;AACL+B,QAAAA,UAAU,CAACF,IAAX,CAAgB,IAAhB;AACD;AACF;;AAED,WAAOxD,OAAO,CAACqD,MAAD,EAAS,CAACR,IAAD,EAAOgB,CAAP,KAAa;AAClC,aAAO,KAAK5C,SAAL,CACJe,IADI,CACCzB,GADD,EACME,IADN,EACYiD,UAAU,CAACG,CAAD,CADtB,EAC2B,IAD3B,EACiChB,IADjC,EAEJZ,IAFI,CAEE6B,YAAD,IAAkB;AACtB5B,QAAAA,QAAQ,GAAG4B,YAAX;AACD,OAJI,CAAP;AAKD,KANa,CAAP,CAMJ7B,IANI,CAOL,MAAM;AACJ,aAAOC,QAAQ,CAACK,KAAT,CAAe,CAAf,EAAkB,EAAlB,EAAsBC,QAAtB,CAA+B,KAA/B,CAAP;AACD,KATI,EAUJrC,CAAD,IAAO;AACL,YAAMD,6BAA6B,CAACC,CAAD,CAAnC;AACD,KAZI,CAAP;AAcD;AAED;;;;;;;;;;;AASA4D,EAAAA,mBAAmB,CAAC1C,IAAD,EAAe2C,YAAf,EAAsD;AACvE,UAAMzC,KAAK,GAAGxB,SAAS,CAACsB,IAAD,CAAvB;AACA,QAAIwB,IAAI,GAAGpB,MAAM,CAACC,KAAP,CAAapB,iBAAiB,GAAGiB,KAAK,CAACI,MAAN,GAAetB,SAAhD,CAAX;AACAwC,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUtB,KAAK,CAACI,MAAhB;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCe,MAAAA,IAAI,CAACd,aAAL,CAAmBF,OAAnB,EAA4B,IAAI,IAAIC,KAApC;AACD,KAFD;AAGAe,IAAAA,IAAI,GAAGpB,MAAM,CAACgC,MAAP,CAAc,CAACZ,IAAD,EAAOpB,MAAM,CAAC2B,IAAP,CAAYY,YAAZ,EAA0B,KAA1B,CAAP,CAAd,CAAP;AAEA,WAAO,KAAK/C,SAAL,CACJe,IADI,CACCzB,GADD,EACMG,SADN,EACiB,IADjB,EACuB,IADvB,EAC6BmC,IAD7B,EAEJZ,IAFI,CAEEC,QAAD,IAAc;AAClB,aAAOA,QAAQ,CAACK,KAAT,CAAe,CAAf,EAAkB,EAAlB,EAAsBC,QAAtB,CAA+B,KAA/B,CAAP;AACD,KAJI,CAAP;AAKD;AAED;;;;;;;;;;;;;;;;;AAeAyB,EAAAA,mBAAmB,GAOhB;AACD,WAAO,KAAKhD,SAAL,CAAee,IAAf,CAAoBzB,GAApB,EAAyBM,OAAzB,EAAkC,IAAlC,EAAwC,IAAxC,EAA8CoB,IAA9C,CAAoDC,QAAD,IAAc;AACtE;AACA,UAAIgC,UAAU,GAAG,CAAChC,QAAQ,CAAC,CAAD,CAAR,GAAe,KAAK,CAArB,IAA2B,CAA5C,CAFsE,CAGtE;;AACA,UAAIiC,eAAe,GAAG,CAACjC,QAAQ,CAAC,CAAD,CAAR,GAAe,KAAK,CAArB,IAA2B,CAAjD,CAJsE,CAKtE;;AACA,UAAIkC,aAAa,GAAG,CAAClC,QAAQ,CAAC,CAAD,CAAR,GAAe,KAAK,CAArB,IAA2B,CAA/C,CANsE,CAOtE;;AACA,UAAImC,SAAS,GAAG,CAACnC,QAAQ,CAAC,CAAD,CAAR,GAAe,KAAK,CAArB,IAA2B,CAA3C;;AACA,UAAIA,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAAhB,IAAqBA,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAArC,IAA0CA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAA5D,EAA+D;AAC7DmC,QAAAA,SAAS,GAAG,IAAZ;AACAD,QAAAA,aAAa,GAAG,KAAhB;AACD;;AACD,UAAIlC,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAAhB,IAAqBA,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAArC,IAA0CA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAA5D,EAA+D;AAC7DiC,QAAAA,eAAe,GAAG,KAAlB;AACD;;AACD,YAAMhC,MAAM,GAAG;AACbmC,QAAAA,OAAO,EAAG,GAAEpC,QAAQ,CAAC,CAAD,CAAI,IAAGA,QAAQ,CAAC,CAAD,CAAI,IAAGA,QAAQ,CAAC,CAAD,CAAI,EADzC;AAEbqC,QAAAA,QAAQ,EAAErC,QAAQ,CAAC,CAAD,CAAR,GAAc,KAAd,GAAsBA,QAAQ,CAAC,CAAD,CAAR,GAAc,GAApC,GAA0CA,QAAQ,CAAC,CAAD,CAF/C;AAGbmC,QAAAA,SAHa;AAIbD,QAAAA,aAJa;AAKbD,QAAAA,eALa;AAMbD,QAAAA;AANa,OAAf;AAQA,aAAO/B,MAAP;AACD,KAzBM,CAAP;AA0BD;AAED;;;;;;;;;;;AASAqC,EAAAA,mBAAmB,CAACnD,IAAD,EAAeoD,UAAf,EAAoD;AACrE,QAAIlD,KAAK,GAAGxB,SAAS,CAACsB,IAAD,CAArB;AACA,UAAMqD,OAAO,GAAGjD,MAAM,CAAC2B,IAAP,CAAYqB,UAAZ,EAAwB,KAAxB,CAAhB;AACA,QAAIE,MAAM,GAAG,CAAb;AACA,QAAItB,MAAM,GAAG,EAAb;AAEA,UAAMuB,IAAI,GAAGF,OAAO,CAAC/C,MAAR,CAAea,QAAf,CAAwB,EAAxB,CAAb;AACA,UAAMqC,QAAQ,GAAG,WAAWC,MAAX,CAAkBF,IAAI,CAACjD,MAAvB,IAAiCiD,IAAlD;AACA,UAAMG,MAAM,GAAGtD,MAAM,CAACgC,MAAP,CAAc,CAAChC,MAAM,CAAC2B,IAAP,CAAYyB,QAAZ,EAAsB,KAAtB,CAAD,EAA+BH,OAA/B,CAAd,CAAf;;AAEA,WAAOC,MAAM,GAAGI,MAAM,CAACpD,MAAvB,EAA+B;AAC7B;AACA,UAAIqD,YAAY,GACdL,MAAM,KAAK,CAAX,GAAe7D,UAAU,GAAG,CAAb,GAAiBS,KAAK,CAACI,MAAN,GAAe,CAA/C,GAAmDb,UADrD;AAEA,UAAImE,SAAS,GACXN,MAAM,GAAGK,YAAT,GAAwBD,MAAM,CAACpD,MAA/B,GACIoD,MAAM,CAACpD,MAAP,GAAgBgD,MADpB,GAEIK,YAHN;AAIA,UAAIxD,MAAM,GAAGC,MAAM,CAACC,KAAP,CACXiD,MAAM,KAAK,CAAX,GAAe,IAAIpD,KAAK,CAACI,MAAN,GAAe,CAAnB,GAAuBsD,SAAtC,GAAkDA,SADvC,CAAb;;AAGA,UAAIN,MAAM,KAAK,CAAf,EAAkB;AAChBnD,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACI,MAAlB;AACAJ,QAAAA,KAAK,CAACK,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCN,UAAAA,MAAM,CAACO,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,SAFD;AAGAiD,QAAAA,MAAM,CAACG,IAAP,CAAY1D,MAAZ,EAAoB,IAAI,IAAID,KAAK,CAACI,MAAlC,EAA0CgD,MAA1C,EAAkDA,MAAM,GAAGM,SAA3D;AACD,OAND,MAMO;AACLF,QAAAA,MAAM,CAACG,IAAP,CAAY1D,MAAZ,EAAoB,CAApB,EAAuBmD,MAAvB,EAA+BA,MAAM,GAAGM,SAAxC;AACD;;AACD5B,MAAAA,MAAM,CAACG,IAAP,CAAYhC,MAAZ;AACAmD,MAAAA,MAAM,IAAIM,SAAV;AACD;;AACD,QAAI/C,QAAJ;AACA,WAAOlC,OAAO,CAACqD,MAAD,EAAS,CAACR,IAAD,EAAOgB,CAAP,KAAa;AAClC,aAAO,KAAK5C,SAAL,CACJe,IADI,CACCzB,GADD,EACMI,YADN,EACoBkD,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiB,IADrC,EAC2C,IAD3C,EACiDhB,IADjD,EAEJZ,IAFI,CAEE6B,YAAD,IAAkB;AACtB5B,QAAAA,QAAQ,GAAG4B,YAAX;AACD,OAJI,CAAP;AAKD,KANa,CAAP,CAMJ7B,IANI,CAMC,MAAM;AACZ,aAAOC,QAAQ,CAACK,KAAT,CAAe,CAAf,EAAkB,EAAlB,EAAsBC,QAAtB,CAA+B,KAA/B,CAAP;AACD,KARM,CAAP;AASD;AAED;;;;;;;;;;AAQA2C,EAAAA,cAAc,CACZ9D,IADY,EAEZiB,SAFY,EAMX;AACD,UAAMf,KAAK,GAAGxB,SAAS,CAACsB,IAAD,CAAvB;AACA,UAAMwB,IAAI,GAAGpB,MAAM,CAAC2B,IAAP,CAAYd,SAAZ,EAAuB,KAAvB,CAAb;AACA,UAAMd,MAAM,GAAGC,MAAM,CAACC,KAAP,CAAa,IAAIH,KAAK,CAACI,MAAN,GAAe,CAAnB,GAAuBkB,IAAI,CAAClB,MAAzC,CAAf;AACAH,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAACI,MAAlB;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCN,MAAAA,MAAM,CAACO,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,KAFD;AAGAe,IAAAA,IAAI,CAACqC,IAAL,CAAU1D,MAAV,EAAkB,IAAI,IAAID,KAAK,CAACI,MAAhC,EAAwC,CAAxC,EAA2CkB,IAAI,CAAClB,MAAhD;AAEA,WAAO,KAAKV,SAAL,CACJe,IADI,CACCzB,GADD,EACMK,WADN,EACmB,IADnB,EACyB,IADzB,EAC+BY,MAD/B,EAEJS,IAFI,CAEEC,QAAD,IAAcA,QAAQ,CAACK,KAAT,CAAe,CAAf,EAAkB,EAAlB,EAAsBC,QAAtB,CAA+B,KAA/B,CAFf,CAAP;AAGD;;AAxTsB","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach, decodeVarint } from \"./utils\";\n//import { StatusCodes, TransportStatusError } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    // TODO:\n  }\n  return e;\n};\n\nconst PATH_SIZE = 4;\nconst PATHS_LENGTH_SIZE = 1;\nconst CLA = 0xe0;\nconst ADDRESS = 0x02;\nconst SIGN = 0x04;\nconst SIGN_HASH = 0x05;\nconst SIGN_MESSAGE = 0x08;\nconst ECDH_SECRET = 0x0a;\nconst VERSION = 0x06;\nconst CHUNK_SIZE = 250;\n\n/**\n * Tron API\n *\n * @example\n * import Trx from \"@ledgerhq/hw-app-trx\";\n * const trx = new Trx(transport)\n */\nexport default class Trx {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"TRX\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"getECDHPairKey\",\n        \"signTransaction\",\n        \"signTransactionHash\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Tron address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey and address\n   * @example\n   * const address = await tron.getAddress(\"44'/195'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(PATHS_LENGTH_SIZE + paths.length * PATH_SIZE);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(CLA, ADDRESS, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address = response\n          .slice(\n            1 + publicKeyLength + 1,\n            1 + publicKeyLength + 1 + addressLength\n          )\n          .toString(\"ascii\");\n        return result;\n      });\n  }\n\n  getNextLength(tx: Buffer) {\n    const field = decodeVarint(tx, 0);\n    const data = decodeVarint(tx, field.pos);\n    if ((field.value & 0x07) === 0) return data.pos;\n    return data.value + data.pos;\n  }\n\n  /**\n   * sign a Tron transaction with a given BIP 32 path and Token Names\n   *\n   * @param path a path in BIP 32 format\n   * @param rawTxHex a raw transaction hex string\n   * @param tokenSignatures Tokens Signatures array\n   * @option version pack message based on ledger firmware version\n   * @option smartContract boolean hack to set limit buffer on ledger device\n   * @return a signature as hex string\n   * @example\n   * const signature = await tron.signTransaction(\"44'/195'/0'/0/0\", \"0a02f5942208704dda506d59dceb40f0f4978f802e5a69080112650a2d747970652e676f6f676c65617069732e636f6d2f70726f746f636f6c2e5472616e73666572436f6e747261637412340a1541978dbd103cfe59c35e753d09dd44ae1ae64621c7121541e2ae49db6a70b9b4757d2137a43b69b24a445780188ef8b5ba0470cbb5948f802e\", [], 105);\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string,\n    tokenSignatures: string[]\n  ): Promise<string> {\n    const paths = splitPath(path);\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    const toSend = [];\n\n    let data = Buffer.alloc(PATHS_LENGTH_SIZE + paths.length * PATH_SIZE);\n    // write path for first chuck only\n    data[0] = paths.length;\n    paths.forEach((element, index) => {\n      data.writeUInt32BE(element, 1 + 4 * index);\n    });\n\n    while (rawTx.length > 0) {\n      // get next message field\n      const newpos = this.getNextLength(rawTx);\n      if (newpos > CHUNK_SIZE) throw new Error(\"Too many bytes to encode.\");\n      if (data.length + newpos > CHUNK_SIZE) {\n        toSend.push(data);\n        data = Buffer.alloc(0);\n        continue;\n      }\n      // append data\n      data = Buffer.concat([data, rawTx.slice(0, newpos)]);\n      rawTx = rawTx.slice(newpos, rawTx.length);\n    }\n    toSend.push(data);\n\n    const startBytes = [];\n    let response;\n\n    const tokenPos = toSend.length;\n    if (tokenSignatures !== undefined) {\n      for (let i = 0; i < tokenSignatures.length; i += 1) {\n        const buffer = Buffer.from(tokenSignatures[i], \"hex\");\n        toSend.push(buffer);\n      }\n    }\n\n    // get startBytes\n    if (toSend.length === 1) {\n      startBytes.push(0x10);\n    } else {\n      startBytes.push(0x00);\n      for (let i = 1; i < toSend.length - 1; i += 1) {\n        if (i >= tokenPos) {\n          startBytes.push(0xa0 | 0x00 | (i - tokenPos)); // eslint-disable-line no-bitwise\n        } else {\n          startBytes.push(0x80);\n        }\n      }\n      if (tokenSignatures !== undefined && tokenSignatures.length) {\n        startBytes.push(0xa0 | 0x08 | (tokenSignatures.length - 1)); // eslint-disable-line no-bitwise\n      } else {\n        startBytes.push(0x90);\n      }\n    }\n\n    return foreach(toSend, (data, i) => {\n      return this.transport\n        .send(CLA, SIGN, startBytes[i], 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        });\n    }).then(\n      () => {\n        return response.slice(0, 65).toString(\"hex\");\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   * sign a Tron transaction hash with a given BIP 32 path\n   *\n   * @param path a path in BIP 32 format\n   * @param rawTxHex a raw transaction hex string\n   * @return a signature as hex string\n   * @example\n   * const signature = await tron.signTransactionHash(\"44'/195'/0'/0/0\", \"25b18a55f86afb10e7aca38d0073d04c80397c6636069193953fdefaea0b8369\");\n   */\n  signTransactionHash(path: string, rawTxHashHex: string): Promise<string> {\n    const paths = splitPath(path);\n    let data = Buffer.alloc(PATHS_LENGTH_SIZE + paths.length * PATH_SIZE);\n    data[0] = paths.length;\n    paths.forEach((element, index) => {\n      data.writeUInt32BE(element, 1 + 4 * index);\n    });\n    data = Buffer.concat([data, Buffer.from(rawTxHashHex, \"hex\")]);\n\n    return this.transport\n      .send(CLA, SIGN_HASH, 0x00, 0x00, data)\n      .then((response) => {\n        return response.slice(0, 65).toString(\"hex\");\n      });\n  }\n\n  /**\n   * get the version of the Tron app installed on the hardware device\n   *\n   * @return an object with a version\n   * @example\n   * const result = await tron.getAppConfiguration();\n   * {\n   *   \"version\": \"0.1.5\",\n   *   \"versionN\": \"105\".\n   *   \"allowData\": false,\n   *   \"allowContract\": false,\n   *   \"truncateAddress\": false,\n   *   \"signByHash\": false\n   * }\n   */\n  getAppConfiguration(): Promise<{\n    allowContract: Boolean,\n    truncateAddress: Boolean,\n    allowData: Boolean,\n    signByHash: Boolean,\n    version: string,\n    versionN: number,\n  }> {\n    return this.transport.send(CLA, VERSION, 0x00, 0x00).then((response) => {\n      // eslint-disable-next-line no-bitwise\n      let signByHash = (response[0] & (1 << 3)) > 0;\n      // eslint-disable-next-line no-bitwise\n      let truncateAddress = (response[0] & (1 << 2)) > 0;\n      // eslint-disable-next-line no-bitwise\n      let allowContract = (response[0] & (1 << 1)) > 0;\n      // eslint-disable-next-line no-bitwise\n      let allowData = (response[0] & (1 << 0)) > 0;\n      if (response[1] === 0 && response[2] === 1 && response[3] < 2) {\n        allowData = true;\n        allowContract = false;\n      }\n      if (response[1] === 0 && response[2] === 1 && response[3] < 5) {\n        truncateAddress = false;\n      }\n      const result = {\n        version: `${response[1]}.${response[2]}.${response[3]}`,\n        versionN: response[1] * 10000 + response[2] * 100 + response[3],\n        allowData,\n        allowContract,\n        truncateAddress,\n        signByHash,\n      };\n      return result;\n    });\n  }\n\n  /**\n   * sign a Tron Message with a given BIP 32 path\n   *\n   * @param path a path in BIP 32 format\n   * @param message hex string to sign\n   * @return a signature as hex string\n   * @example\n   * const signature = await tron.signPersonalMessage(\"44'/195'/0'/0/0\", \"43727970746f436861696e2d54726f6e5352204c6564676572205472616e73616374696f6e73205465737473\");\n   */\n  signPersonalMessage(path: string, messageHex: string): Promise<string> {\n    let paths = splitPath(path);\n    const message = Buffer.from(messageHex, \"hex\");\n    let offset = 0;\n    let toSend = [];\n\n    const size = message.length.toString(16);\n    const sizePack = \"00000000\".substr(size.length) + size;\n    const packed = Buffer.concat([Buffer.from(sizePack, \"hex\"), message]);\n\n    while (offset < packed.length) {\n      // Use small buffer to be compatible with old and new protocol\n      let maxChunkSize =\n        offset === 0 ? CHUNK_SIZE - 1 - paths.length * 4 : CHUNK_SIZE;\n      let chunkSize =\n        offset + maxChunkSize > packed.length\n          ? packed.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        packed.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        packed.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    let response;\n    return foreach(toSend, (data, i) => {\n      return this.transport\n        .send(CLA, SIGN_MESSAGE, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        });\n    }).then(() => {\n      return response.slice(0, 65).toString(\"hex\");\n    });\n  }\n\n  /**\n   * get Tron address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @param publicKey address public key to generate pair key\n   * @return shared key hex string,\n   * @example\n   * const signature = await tron.getECDHPairKey(\"44'/195'/0'/0/0\", \"04ff21f8e64d3a3c0198edfbb7afdc79be959432e92e2f8a1984bb436a414b8edcec0345aad0c1bf7da04fd036dd7f9f617e30669224283d950fab9dd84831dc83\");\n   */\n  getECDHPairKey(\n    path: string,\n    publicKey: string\n  ): Promise<{\n    publicKey: string,\n    address: string,\n  }> {\n    const paths = splitPath(path);\n    const data = Buffer.from(publicKey, \"hex\");\n    const buffer = Buffer.alloc(1 + paths.length * 4 + data.length);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    data.copy(buffer, 1 + 4 * paths.length, 0, data.length);\n\n    return this.transport\n      .send(CLA, ECDH_SECRET, 0x00, 0x01, buffer)\n      .then((response) => response.slice(0, 65).toString(\"hex\"));\n  }\n}\n"],"file":"Trx.js"}