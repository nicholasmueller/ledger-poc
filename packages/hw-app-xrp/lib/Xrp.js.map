{"version":3,"sources":["../src/Xrp.js"],"names":["Xrp","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","path","display","chainCode","ed25519","bipPath","BIPPath","fromString","toPathArray","curveMask","cla","ins","p1","p2","data","Buffer","alloc","length","writeInt8","forEach","segment","index","writeUInt32BE","response","send","result","publicKeyLength","addressLength","publicKey","slice","toString","address","signTransaction","rawTxHex","rawTx","from","apdus","offset","isFirst","maxChunkSize","hasMore","chunkSize","apdu","copy","push","getAppConfiguration","version"],"mappings":"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","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BIPPath from \"bip32-path\";\n\n/**\n * XRP API\n *\n * @example\n * import Transport from \"@ledgerhq/hw-transport-node-hid\";\n * // import Transport from \"@ledgerhq/hw-transport-u2f\"; // for browser\n * import Xrp from \"@ledgerhq/hw-app-xrp\";\n * import { encode } from 'ripple-binary-codec';\n *\n * function establishConnection() {\n *     return Transport.create()\n *         .then(transport => new Xrp(transport));\n * }\n *\n * function fetchAddress(xrp) {\n *     return xrp.getAddress(\"44'/144'/0'/0/0\");\n * }\n *\n * function signTransaction(xrp, deviceData, seqNo) {\n *     let transactionJSON = {\n *         TransactionType: \"Payment\",\n *         Account: deviceData.address,\n *         Destination: \"rTooLkitCksh5mQa67eaa2JaWHDBnHkpy\",\n *         Amount: \"1000000\",\n *         Fee: \"15\",\n *         Flags: 2147483648,\n *         Sequence: seqNo,\n *         SigningPubKey: deviceData.publicKey.toUpperCase()\n *     };\n *\n *     const transactionBlob = encode(transactionJSON);\n *\n *     console.log('Sending transaction to device for approval...');\n *     return xrp.signTransaction(\"44'/144'/0'/0/0\", transactionBlob);\n * }\n *\n * function prepareAndSign(xrp, seqNo) {\n *     return fetchAddress(xrp)\n *         .then(deviceData => signTransaction(xrp, deviceData, seqNo));\n * }\n *\n * establishConnection()\n *     .then(xrp => prepareAndSign(xrp, 123))\n *     .then(signature => console.log(`Signature: ${signature}`))\n *     .catch(e => console.log(`An error occurred (${e.message})`));\n */\nexport default class Xrp {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"XRP\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\"getAddress\", \"signTransaction\", \"getAppConfiguration\"],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get XRP address for a given BIP 32 path.\n   *\n   * @param path a path in BIP 32 format\n   * @param display optionally enable or not the display\n   * @param chainCode optionally enable or not the chainCode request\n   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * const result = await xrp.getAddress(\"44'/144'/0'/0/0\");\n   * const { publicKey, address } = result;\n   */\n  async getAddress(\n    path: string,\n    display?: boolean,\n    chainCode?: boolean,\n    ed25519?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    const curveMask = ed25519 ? 0x80 : 0x40;\n\n    const cla = 0xe0;\n    const ins = 0x02;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = curveMask | (chainCode ? 0x01 : 0x00);\n    const data = Buffer.alloc(1 + bipPath.length * 4);\n\n    data.writeInt8(bipPath.length, 0);\n    bipPath.forEach((segment, index) => {\n      data.writeUInt32BE(segment, 1 + index * 4);\n    });\n\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n\n    const result = {};\n    const publicKeyLength = response[0];\n    const addressLength = response[1 + publicKeyLength];\n\n    result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n\n    result.address = response\n      .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n      .toString(\"ascii\");\n\n    if (chainCode) {\n      result.chainCode = response\n        .slice(\n          1 + publicKeyLength + 1 + addressLength,\n          1 + publicKeyLength + 1 + addressLength + 32\n        )\n        .toString(\"hex\");\n    }\n\n    return result;\n  }\n\n  /**\n   * sign a XRP transaction with a given BIP 32 path\n   *\n   * The rawTxHex parameter is the serialized transaction blob represented as\n   * hex.\n   *\n   * @param path a path in BIP 32 format\n   * @param rawTxHex a raw hex string representing a serialized transaction blob.\n   *        This parameter can be encoded using [ripple-binary-codec](https://www.npmjs.com/package/ripple-binary-codec).\n   *        See https://xrpl.org/serialization.html for more documentation on the serialization format.\n   * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)\n   * @return a signature as hex string\n   * @example\n   * const signature = await xrp.signTransaction(\"44'/144'/0'/0/0\", \"12000022800000002400000002614000000001315D3468400000000000000C73210324E5F600B52BB3D9246D49C4AB1722BA7F32B7A3E4F9F2B8A1A28B9118CC36C48114F31B152151B6F42C1D61FE4139D34B424C8647D183142ECFC1831F6E979C6DA907E88B1CAD602DB59E2F\");\n   */\n  async signTransaction(\n    path: string,\n    rawTxHex: string,\n    ed25519?: boolean\n  ): Promise<string> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    const rawTx = Buffer.from(rawTxHex, \"hex\");\n    const curveMask = ed25519 ? 0x80 : 0x40;\n\n    const apdus = [];\n    let offset = 0;\n\n    while (offset !== rawTx.length) {\n      const isFirst = offset === 0;\n      const maxChunkSize = isFirst ? 150 - 1 - bipPath.length * 4 : 150;\n\n      const hasMore = offset + maxChunkSize < rawTx.length;\n      const chunkSize = hasMore ? maxChunkSize : rawTx.length - offset;\n\n      const apdu = {\n        cla: 0xe0,\n        ins: 0x04,\n        p1: (isFirst ? 0x00 : 0x01) | (hasMore ? 0x80 : 0x00),\n        p2: curveMask,\n        data: isFirst\n          ? Buffer.alloc(1 + bipPath.length * 4 + chunkSize)\n          : Buffer.alloc(chunkSize),\n      };\n\n      if (isFirst) {\n        apdu.data.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          apdu.data.writeUInt32BE(segment, 1 + index * 4);\n        });\n        rawTx.copy(\n          apdu.data,\n          1 + bipPath.length * 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        rawTx.copy(apdu.data, 0, offset, offset + chunkSize);\n      }\n\n      apdus.push(apdu);\n      offset += chunkSize;\n    }\n\n    let response = Buffer.alloc(0);\n    for (let apdu of apdus) {\n      response = await this.transport.send(\n        apdu.cla,\n        apdu.ins,\n        apdu.p1,\n        apdu.p2,\n        apdu.data\n      );\n    }\n\n    // the last 2 bytes are status code from the hardware\n    return response.slice(0, response.length - 2).toString(\"hex\");\n  }\n\n  /**\n   * get the version of the XRP app installed on the hardware device\n   *\n   * @return an object with a version\n   * @example\n   * const result = await xrp.getAppConfiguration();\n   *\n   * {\n   *   \"version\": \"1.0.3\"\n   * }\n   */\n  async getAppConfiguration(): Promise<{\n    version: string,\n  }> {\n    const response = await this.transport.send(0xe0, 0x06, 0x00, 0x00);\n    const result = {};\n    result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n    return result;\n  }\n}\n"],"file":"Xrp.js"}